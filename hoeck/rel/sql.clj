;   Copyright (c) 2009, Erik Soehnel All rights reserved.
;
;   Redistribution and use in source and binary forms, with or without
;   modification, are permitted provided that the following conditions
;   are met:
;
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;
;     * Redistributions in binary form must reproduce the above
;       copyright notice, this list of conditions and the following
;       disclaimer in the documentation and/or other materials
;       provided with the distribution.
;
;   THIS SOFTWARE IS PROVIDED BY THE AUTHOR 'AS IS' AND ANY EXPRESSED
;   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
;   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
;   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
;   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

(ns hoeck.rel.sql
  (:use hoeck.library
	hoeck.rel.operators
        clojure.walk
	clojure.contrib.except	
        clojure.contrib.pprint
        [clojure.contrib.def :only [defalias]])
  (:require hoeck.rel.non-lazy
            [hoeck.rel.expressions :as e]
            [clojure.contrib.sql :as ccsql]	
            [clojure.contrib.sql.internal :as ccsqli])
  (:import (clojure.lang IFn ILookup)
           (java.util Collection Set)
           (java.sql Connection Types)))

;; sql 

(defn sql-quote 
  "Given an object, use (str object) to obtain its printed representation and
  quote it so that an sql-interpreter reads it correctly."
  [s]
  (str \' (-> s str (.replace "\\" "\\\\") (.replace "'" "\\'") (.replace "\"" (str \\ \"))) \'))

(defn sql-symbol
    "Throws an error if (str s) is not a valid sql-identifier
  (table-name, column-name ..), otherwise returns (str s).
  If s is a keyword, use name instead of str."
    [s] 
    (let [s (if (keyword? s) (name s) (str s))
          [n _] (re-matches #"^(\w|\.)+$" s)];; also check for leading digits?
      (or n (throwf "`%s' is not a valid sql-symbol." s))))

(defn sql-print
  "given a literal number, symbol, date, keyword or string, print it so that it
  is readable by an sql-interpreter."
  [s]
  (if (number? s) ;; todo
    (str s)
    (sql-quote s)))


;; sql connections (java.sql.Connection)

(defn set-connection
  "set clojure.contrib.sql.internal/*db* :connection to a permanent connection."
  [connection-param-map]
  (alter-var-root #'ccsqli/*db* assoc
		  :connection (ccsqli/get-connection connection-param-map)
		  :level 0
		  :rollback (atom false)))

(defalias connection ccsql/connection)
(defalias transaction ccsql/transaction)

(defn query
  "Executes an sql-expression and returns a resultset-seq"
  ([expr]
     (with-open [s (.createStatement (connection))]
       (doall (resultset-seq (.executeQuery s expr))))))

(defn execute
  "Executes an sql-statement and returns nil. When more than one expr is present
  stack expressions with .addBatch and execute them at one with executeBatch."
  ([expr]
     (def _ee expr)
     (with-open [s (.createStatement (connection))]
       (when-not (empty? expr) (.execute s expr))))
  ([expr & exprs]
     (def _eee (cons expr exprs))
     (let [es (remove empty? (cons expr exprs))]
       (with-open [s (.createStatement (connection))]
         (when-not (empty? es)
           (doseq [e es] (.addBatch s e))
           (seq (.executeBatch s)))))))

(defn execute-insert
  "Executes sql insert-expressions on connection. Return the values of one
  autogenerated key, key-col, if key-col (a symbol) is not nil."
  [key-col & expr]
  (def _e expr)
  (with-open [s (.createStatement (connection))]
    (if key-col
      (let [a (-> key-col name .toUpperCase vector into-array)]        
        (doall (map #(do (.executeUpdate s % a)
                         (-> s .getGeneratedKeys resultset-seq first first val))
                    expr)))
      (do (dorun (map #(.executeUpdate s %) expr))
          nil))))


(comment ;; example connections

  (set-connection {:classname "com.sybase.jdbc2.jdbc.SybDriver" 
                   :subprotocol "sybase:Tds" ;; ^= what
                   :subname "localhost:2638/temp" ;; ^= where
                   ;; symbols: connection properties
                   'user "dbo"
                   'password "-" 
                   'create false})
  (set-connection {:classname "org.apache.derby.jdbc.EmbeddedDriver"
                   :subprotocol "derby"
                   :subname "/tmp/test.db"
                   ;; symbols: connection properties
                   'create false})
  )

(defmacro join= [R S a b]
  `(join ~R ~S (e/join-expr '= ~a ~b)))

(defmacro outer-join= [R S a b]
  `(outer-join ~R ~S (e/join-expr = ~a ~b)))


;; sql-expressions from hoeck.rel.conditions

;;(defn code-walk
;;  "Like prewalk, but stop walking on quoted forms."
;;  [f form]
;;  (if (and (list? form) (= (first form) 'quote))
;;    form
;;    (walk (partial code-walk f) identity (f form))))

;;(defn condition-sql-expr
;;  "given a condition, return its expression as an sql-string"
;;  [c]
;;  (print-str 
;;	 (reduce #(code-walk %2 %1)
;;		 (condition-expr c 
;;				 ;; flag fields (symbol metadata)
;;				 #(with-meta (-> % name symbol) {:sql :field}))
;;		 [;; replace str with +
;;		  #(if (and (seq? %) (= (first %) 'str)) (list* '+ (next %)) %)
;;		  ;; flag operators
;;		  #(if (and (seq? %) (symbol? (first %)))
;;		     (list* (with-meta (first %) {:sql :operator}) (next %))
;;		     %)
;;		  ;; sql-quote strings
;;		  #(cond (or (and (symbol? %)
;;                                  (not (#{:field :operator} (:sql (meta %)))))
;;                             (keyword? %))
;;                         (sql-quote (name %))
;;                         (string? %)
;;                         (sql-quote %)
;;                         :else %)
;;                  ;; expand operators: (and a b c) -> (a and b and c)
;;                  ;; and functions (lower name) -> " lower(name) "
;;		  #(if (seq? %)
;;		     (if-let [trans (sql-condition-ops (first %))]
;;		       (trans (list* (with-meta (first %) {:sql :operator}) (next %)))
;;		       (list* (with-meta (first %) {:sql :function})))
;;		     %)
;;                  ;; print bigints without the trailing M
;;                  #(cond (number? %) (str %)
;;                         :else %)
;;                  ])))

(require 'hoeck.rel.sql.relations)
(require 'hoeck.rel.sql.jdbc)
(require 'hoeck.rel.sql.create)
(require 'hoeck.rel.sql.update)


